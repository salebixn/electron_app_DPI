function Comm(towns) {
	// таблица с расстояниями между городами

	// массив, где будут храниться все просчитанные маршруты
	var path = [];

	// порядковый номер текущего маршрута
	var counter = 0;

	// самый короткий путь — сразу ставим заведомо большим, чтобы уменьшать его по мере работы алгоритма
	var minPath = 10000;

	// номер самого короткого маршрута
	var minCounter;

	// перебираем все варианты перемещения по городам
	for (var i1 = 0; i1 <= 4; i1++) {
		for (var i2 = 0; i2 <= 4; i2++) {
			for (var i3 = 0; i3 <= 4; i3++) {
				for (var i4 = 0; i4 <= 4; i4++) {
					for (var i5 = 0; i5 <= 4; i5++) {

						// нельзя посещать один и тот же город больше одного раза
						if (
							(i1 != i2) && (i1 != i3) && (i1 != i4) && (i1 != i5) &&
							(i2 != i3) && (i2 != i4) && (i2 != i5) &&
							(i3 != i4) && (i3 != i5) &&
							(i4 != i5)
						) {
							// запоминаем текущий путь
							path[counter] = (i1 + 1) + ' → ' + (i2 + 1) + ' → ' + (i3 + 1) + ' → ' + (i4 + 1) + ' → ' + (i5 + 1);
							// выводим его в консоль
							//console.log(path[counter]);
							// если общее расстоения этого пути меньше минимального
							if ((towns[i1][i2] + towns[i2][i3] + towns[i3][i4] + towns[i4][i5]) < minPath) {
								// то мы запоминаем это минимальное расстояние
								minPath = towns[i1][i2] + towns[i2][i3] + towns[i3][i4] + towns[i4][i5];
								// выводим его в консоль
								//console.log(minPath);
								// запоминаем номер этого маршрута с минимальным расстоянием
								minCounter = counter;
							}
							// когда всё сделали, увеличиваем номер маршрута
							counter += 1;
						}
					}
				}
			}
		}
	}
	// когда прошли все варианты, выводим найденное решение
	return `${path[minCounter]}, ${minPath} км`;
}

module.exports = {Comm: Comm};

/*array=[[0, 5, 6, 14, 11],
		[10, 0, 7, 10, 7],
		[6, 7, 0, 8, 7],
		[14, 5, 8, 0, 5],
		[15, 6, 7, 9, 0]];

console.log(Comm(array));*/